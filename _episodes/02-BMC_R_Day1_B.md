---
# Please do not edit this file directly; it is auto generated.
# Instead, please edit 02-BMC_R_Day1_B.md in _episodes_rmd/
title: "R variables and data types"
author: "Nicholas Ho, Richard Morris, Darya Vanichkina"
keypoints:
- R supports multiple variable types
- Errors often result because of trying to perform an unsupported operation on a specific data type
- Errors can be cryptic to interpret
- We can use helper packages to import and filter data in R
objectives:
- Assign values to objects in R.
- Solve simple arithmetic operations in R.
- Describe what a data frame is.
questions: R data types that will be useful in your own work
source: Rmd
teaching: 120
exercises: 60
---



[Back to homepage](https://n-ho.github.io/bmc_r_workshop_2018/)



### R variables and data types

First, we introduce the common variable types and data types that you'll be working with in R. Commonly, errors involve using the wrong variable or data type

**Variable type** | **Type** | **Example**
------------|---------------|---------------------------------
integer | Whole numbers | 1, 100, -9
numeric | Decimals | 0.1, -0.09, 234.567
character | Text | "A", "hello", "welcome"
logical | Booleans | TRUE or FALSE
factor | Categorical | "green", "blue", "red", "purple"

**Data type** | **Type**
---------------|------------------------------------------------
vector | 1D collection of variables of the same type
matrix | 2D collection of variables of the same type
data.frame | 2D collection of variables of multiple types


![R variable and data types](Rvariablesdata.jpg)

## Getting Started


### Working directory
We've created this project in a "working directory". To check where this is, use:

~~~
getwd()
~~~
{: .language-r}



~~~
[1] "/Users/darya/OneDrive - The University of Sydney (Staff)/Training/18_11_BMCNickHo/2018_bmctest/_episodes_rmd"
~~~
{: .output}


### Calculating things in R

Standard math functions work in R:

~~~
2+3
~~~
{: .language-r}



~~~
[1] 5
~~~
{: .output}



~~~
1/1000
~~~
{: .language-r}



~~~
[1] 0.001
~~~
{: .output}



~~~
sqrt(2)
~~~
{: .language-r}



~~~
[1] 1.414214
~~~
{: .output}

We can store values in variables. Variables are a way to both store data and to label data.

~~~
myvariable <- 3
myvariable
~~~
{: .language-r}



~~~
[1] 3
~~~
{: .output}



~~~
myvariable = 3
myvariable
~~~
{: .language-r}



~~~
[1] 3
~~~
{: .output}



~~~
3 -> myvariable
myvariable
~~~
{: .language-r}



~~~
[1] 3
~~~
{: .output}



~~~
myvariable^2
~~~
{: .language-r}



~~~
[1] 9
~~~
{: .output}
## Variable and Data Types

There are several different types of data you can use in R. We'll examine a few common ones in a little more detail.

### Text
Strings are known as "character" in R. Use the double quotes `"` or single quotes `'` to wrap around the string

~~~
myname <- "nick"
~~~
{: .language-r}

We can use the `class()` function to see what data type it is

~~~
class(myname)
~~~
{: .language-r}



~~~
[1] "character"
~~~
{: .output}

### Numbers
Numbers have different classes. The most common two are `integer` and `numeric`. Integers are whole numbers:

~~~
favourite.integer <- as.integer(8)
print(favourite.integer)
~~~
{: .language-r}



~~~
[1] 8
~~~
{: .output}



~~~
class(favourite.integer)
~~~
{: .language-r}



~~~
[1] "integer"
~~~
{: .output}

Numbers can be `numeric` which are decimals:

~~~
favourite.numeric <- as.numeric(8.8)
print(favourite.numeric)
~~~
{: .language-r}



~~~
[1] 8.8
~~~
{: .output}



~~~
class(favourite.numeric)
~~~
{: .language-r}



~~~
[1] "numeric"
~~~
{: .output}



~~~
pvalue.threshold <- 0.05
~~~
{: .language-r}

### Logical (True/False)
We use the `==` to test for equality in R

~~~
class(TRUE)
~~~
{: .language-r}



~~~
[1] "logical"
~~~
{: .output}



~~~
favourite.numeric == 8.8
~~~
{: .language-r}



~~~
[1] TRUE
~~~
{: .output}



~~~
favourite.numeric == 9.9
~~~
{: .language-r}



~~~
[1] FALSE
~~~
{: .output}


### Vectors
We can create 1D data structures called "vectors".

~~~
1:10
~~~
{: .language-r}



~~~
 [1]  1  2  3  4  5  6  7  8  9 10
~~~
{: .output}



~~~
2*(1:10)
~~~
{: .language-r}



~~~
 [1]  2  4  6  8 10 12 14 16 18 20
~~~
{: .output}



~~~
seq(0, 10, 2)
~~~
{: .language-r}



~~~
[1]  0  2  4  6  8 10
~~~
{: .output}


We can store vectors and perform operations on them.

~~~
myvector <- 1:10
myvector
~~~
{: .language-r}



~~~
 [1]  1  2  3  4  5  6  7  8  9 10
~~~
{: .output}



~~~
2^myvector
~~~
{: .language-r}



~~~
 [1]    2    4    8   16   32   64  128  256  512 1024
~~~
{: .output}



~~~
b <- c(3,4,5)
b^2
~~~
{: .language-r}



~~~
[1]  9 16 25
~~~
{: .output}



~~~
disorders <- c("autism","ocd", "depression", "ocd", "anxiety", "autism")
disorders
~~~
{: .language-r}



~~~
[1] "autism"     "ocd"        "depression" "ocd"        "anxiety"   
[6] "autism"    
~~~
{: .output}


### Factors
Factors store categorical data. Under the hood, factors are actually integers that have a string label attached to each unique integer. For example, if we have a long list of Male/Female labels for each of our patients, this will be stored a "row" of zeros and ones by R.

~~~
disorders <- as.factor(disorders)
class(disorders)
~~~
{: .language-r}



~~~
[1] "factor"
~~~
{: .output}

How many categories are there for ethnicity and what are they?

~~~
levels(disorders)
~~~
{: .language-r}



~~~
[1] "anxiety"    "autism"     "depression" "ocd"       
~~~
{: .output}



~~~
nlevels(disorders)
~~~
{: .language-r}



~~~
[1] 4
~~~
{: .output}

A factor can be ordered. This makes sense in the context of a ranking such as a survey response, e.g. Strongly agree to Strong disagree.

~~~
responses <- c("low", "high", "medium", "low", "low", "high", "high", "medium", "medium")

myfactor <- factor(responses, levels = c("low", "medium", "high"))

myorderedfactor <- factor(responses, levels = c("low", "medium", "high"), ordered = TRUE)

levels(myfactor)
~~~
{: .language-r}



~~~
[1] "low"    "medium" "high"  
~~~
{: .output}
By default, factors will be ordered in alphabetical order.

Now our factor is ordered, we can find the lowest category by using `min()`

~~~
min(myfactor) #this will fail
~~~
{: .language-r}



~~~
Error in Summary.factor(structure(c(1L, 3L, 2L, 1L, 1L, 3L, 3L, 2L, 2L: 'min' not meaningful for factors
~~~
{: .error}



~~~
min(myorderedfactor)
~~~
{: .language-r}



~~~
[1] low
Levels: low < medium < high
~~~
{: .output}



### Working with data

A lot of the time in R, we are working with tables of data, know as "data frames".

Commonly,

**rows** may represent instances e.g. *data points*, *patients*, *events*, *samples*, etc. while

**columns** will represent different types of data associated with each data point or instance e.g. *Name*, *ID*, *location*, *time*, *value*...

It is good practive to have a single row for every instance, and an individual, distinct measurement in each of the columns (not multiple measurements in one or redunant information in multiple columns).

Here is an example data frame:


~~~
bmc.data <- data.frame(fname = c("Alice", "Bob", "Carol", "David"),
                       gender = as.factor(c("Female", "Male", "Female", "Male")),
                       disorder = c("autism", "anxiety", "autism", "depression"),
                       age = c(20, 45, 15, 12),
                       biomarker1 = c(5.70, 4.96, 1.37, 10.44),
                       clinicalstage = c("1b", "1a", "1a", "2"),
                       stringsAsFactors = FALSE)
~~~
{: .language-r}

### Viewing The Data
Use the function `View()` to visually inspect the data in a new RStudio pane:

~~~
View(bmc.data)
~~~
{: .language-r}

How many rows and columns do we have?

~~~
nrow(bmc.data)
~~~
{: .language-r}



~~~
[1] 4
~~~
{: .output}



~~~
ncol(bmc.data)
~~~
{: .language-r}



~~~
[1] 6
~~~
{: .output}



~~~
dim(bmc.data)
~~~
{: .language-r}



~~~
[1] 4 6
~~~
{: .output}


### Accessing Subsets
Return the first N rows of your data frame

~~~
head(bmc.data)
~~~
{: .language-r}



~~~
  fname gender   disorder age biomarker1 clinicalstage
1 Alice Female     autism  20       5.70            1b
2   Bob   Male    anxiety  45       4.96            1a
3 Carol Female     autism  15       1.37            1a
4 David   Male depression  12      10.44             2
~~~
{: .output}

The default for the `head()` function is to show the first 6 rows. How do we know this? Type `?` infront of the function name in your console

~~~
?head
~~~
{: .language-r}

Return the first 3 rows of your data frame

~~~
head(bmc.data, n = 3)
~~~
{: .language-r}



~~~
  fname gender disorder age biomarker1 clinicalstage
1 Alice Female   autism  20       5.70            1b
2   Bob   Male  anxiety  45       4.96            1a
3 Carol Female   autism  15       1.37            1a
~~~
{: .output}



~~~
head(bmc.data, 3)
~~~
{: .language-r}



~~~
  fname gender disorder age biomarker1 clinicalstage
1 Alice Female   autism  20       5.70            1b
2   Bob   Male  anxiety  45       4.96            1a
3 Carol Female   autism  15       1.37            1a
~~~
{: .output}



~~~
bmc.data[1:3, ]
~~~
{: .language-r}



~~~
  fname gender disorder age biomarker1 clinicalstage
1 Alice Female   autism  20       5.70            1b
2   Bob   Male  anxiety  45       4.96            1a
3 Carol Female   autism  15       1.37            1a
~~~
{: .output}



~~~
bmc.data[c(1, 2, 3), ]
~~~
{: .language-r}



~~~
  fname gender disorder age biomarker1 clinicalstage
1 Alice Female   autism  20       5.70            1b
2   Bob   Male  anxiety  45       4.96            1a
3 Carol Female   autism  15       1.37            1a
~~~
{: .output}



~~~
bmc.data[c(TRUE, TRUE, TRUE, FALSE), ]
~~~
{: .language-r}



~~~
  fname gender disorder age biomarker1 clinicalstage
1 Alice Female   autism  20       5.70            1b
2   Bob   Male  anxiety  45       4.96            1a
3 Carol Female   autism  15       1.37            1a
~~~
{: .output}


Return the last 2 rows in a data set

~~~
tail(bmc.data, 2)
~~~
{: .language-r}



~~~
  fname gender   disorder age biomarker1 clinicalstage
3 Carol Female     autism  15       1.37            1a
4 David   Male depression  12      10.44             2
~~~
{: .output}


Return the "age" column in the data set

~~~
bmc.data$age
~~~
{: .language-r}



~~~
[1] 20 45 15 12
~~~
{: .output}



~~~
bmc.data[, 4]
~~~
{: .language-r}



~~~
[1] 20 45 15 12
~~~
{: .output}



~~~
bmc.data[, "age"]
~~~
{: .language-r}



~~~
[1] 20 45 15 12
~~~
{: .output}



~~~
bmc.data[, c(F, F, F, T, F, F, F)]
~~~
{: .language-r}



~~~
[1] 20 45 15 12
~~~
{: .output}

Return only the first 3 rows and columns 2 and 5 of the data set

~~~
bmc.data[1:3, c(2,5)]
~~~
{: .language-r}



~~~
  gender biomarker1
1 Female       5.70
2   Male       4.96
3 Female       1.37
~~~
{: .output}

Return the columns named "fname" and "biomarker1"

~~~
bmc.data[,c("fname", "biomarker1")]
~~~
{: .language-r}



~~~
  fname biomarker1
1 Alice       5.70
2   Bob       4.96
3 Carol       1.37
4 David      10.44
~~~
{: .output}


### Filtering the data

Return only the rows (patients) who are Female

~~~
bmc.data[bmc.data$gender == "Female", ]
~~~
{: .language-r}



~~~
  fname gender disorder age biomarker1 clinicalstage
1 Alice Female   autism  20       5.70            1b
3 Carol Female   autism  15       1.37            1a
~~~
{: .output}

What exactly happened here? We made a vector of `TRUE/FALSE` statements, for each row in which this condition is true and then we subset rows in which the index is true

~~~
females <- bmc.data$gender == "Female"
females
~~~
{: .language-r}



~~~
[1]  TRUE FALSE  TRUE FALSE
~~~
{: .output}



~~~
bmc.data[females, ]
~~~
{: .language-r}



~~~
  fname gender disorder age biomarker1 clinicalstage
1 Alice Female   autism  20       5.70            1b
3 Carol Female   autism  15       1.37            1a
~~~
{: .output}

Another way to subset the patients is with the `which()` function

~~~
females <- which(bmc.data$gender == "Female")
females
~~~
{: .language-r}



~~~
[1] 1 3
~~~
{: .output}



~~~
bmc.data[females, ]
~~~
{: .language-r}



~~~
  fname gender disorder age biomarker1 clinicalstage
1 Alice Female   autism  20       5.70            1b
3 Carol Female   autism  15       1.37            1a
~~~
{: .output}



~~~
bmc.data[which(bmc.data$gender == "Female"), ]
~~~
{: .language-r}



~~~
  fname gender disorder age biomarker1 clinicalstage
1 Alice Female   autism  20       5.70            1b
3 Carol Female   autism  15       1.37            1a
~~~
{: .output}


What if we want all patients older than 16 years of age?

~~~
bmc.data[bmc.data$age > 16, ]
~~~
{: .language-r}



~~~
  fname gender disorder age biomarker1 clinicalstage
1 Alice Female   autism  20       5.70            1b
2   Bob   Male  anxiety  45       4.96            1a
~~~
{: .output}

### Adding records
Add a new row to the data set using the rbind() function:


~~~
new.person <- data.frame(fname = "Evelyn",
                         gender = "Female",
                         disorder = "anxiety",
                         age = 27,
                         biomarker1 = 40.8,
                         clinicalstage = "2")

bmc.data <- rbind(bmc.data, new.person)
~~~
{: .language-r}

> ## Section quiz
>
> 1. Return those patients whose clinical stage is "1a"
>
> 2. Return those patients whose biomarker1 value is less than 6.7
>
> 3. Return just the first name of all patients older than 16 years of age
>
> {: .source}
>
> > ## Solution
> >
> > 1. Return those patients whose clinical stage is "1a"
> >
> > ~~~
> > bmc.data[bmc.data$clinicalstage == "1a",]
> > ~~~
> > 2. Return those patients whose biomarker1 value is less than 6.7
> >
> > ~~~
> > bmc.data[bmc.data$biomarker1 < 6.7,]
> > ~~~
> > 3. Return just the first name of all patients older than 16 years of age
> >
> > ~~~
> > bmc.data[bmc.data$age > 16,]$fname
> > bmc.data[bmc.data$age > 16,"fname"]
> > ~~~
> > {: .output}
> {: .solution}
{: .challenge}
